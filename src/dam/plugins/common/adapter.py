import os, time
from dam.core.dam_repository.models import Type
from dam.variants.models import Variant
from dam.repository.models import get_storage_file_name
from dam.plugins.common.utils import get_source_rendition
from dam.plugins.common.cmdline import splitstring, import_cmd
from mprocessor import log
from dam.mprocessor.servers import generic_cmd


class Adapter:
    """
    Base class for all the plugins that generate a new rendition starting from
    a source variant in an item, using a remote command line.  
    """
    get_cmdline = None  # override to provide specialized behaviour
    cmdline = None      # string with the commandine to execute
    env = {}            # environment for the executioni
    item = None         # the item object identifyed by item_id
    source = None       # the source Component
    out_comp = None     # the component generated by this adapter
    out_file = None     # the output file
    out_type = None   # the dam_repository.Type of the output Component
    fake = False        # set to have just the command line printed

    def __init__(self, workspace, item_id, source_variant_name):    
        if self.get_cmdline is None:
            raise Exception('Adapter is an abstract base class: instantiate a derived class')
        self.workspace = workspace
        self.item, self.source = get_source_rendition(item_id, source_variant_name, workspace)

    def handle_result(self, result):
        log.debug('handle_result %s' % str(result))
        log.debug("[save_component] component %s" % self.out_comp.pk)        
        log.debug('##############\n%s\n' % result['data'])
        
        directory, name = os.path.split(self.out_file)
        self.out_comp.uri = name
        self.out_comp.save()
        self.item.update_time = time.time()
        self.item.save()

        return self.out_file
        
    def handle_error(self, result):
        pass

    def execute(self, output_variant_name, output_type, **params):     
        # get basic data (avoid creating stuff in DB)
        try:
            self.get_cmdline(output_variant_name, output_type, **params)
            output_variant = Variant.objects.get(name = output_variant_name)
            self.out_comp = self.item.create_variant(output_variant, self.workspace, self.out_type)
            self.out_comp.source = self.source
            args = splitstring(self.cmdline)
        except Exception, e:
            log.error('Error in %s: %s %s' % (self.__class__.__name__, type(e), str(e)))
            raise
        else:
            if self.fake:
                log.debug('######### Command line:\n%s' % str(args))
            else:
                try:
                    result = generic_cmd.call.delay(self.remote_exe, args,
                                                    self.env).get()
                    return self.handle_result(result)
                except:
                    self.handle_error(None)
                    raise
