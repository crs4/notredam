import os, time
from twisted.python.failure import Failure
from dam.core.dam_repository.models import Type
from dam.variants.models import Variant
from dam.repository.models import get_storage_file_name
from dam.plugins.common.utils import get_source_rendition
from dam.plugins.common.cmdline import splitstring, import_cmd
from mediadart import log
from mediadart.mqueue.mqclient_twisted import Proxy


class Adapter:
    """
    Base class for all the plugins that generate a new rendition starting from
    a source variant in an item, using a remote command line.  
    """
    md_server = 'GenericCmdline'  # default value
    get_cmdline = None  # override to provide specialized behaviour
    cmdline = None      # string with the commandine to execute
    env = {}            # environment for the executioni
    item = None         # the item object identifyed by item_id
    source = None       # the source Component
    out_comp = None     # the component generated by this adapter
    out_file = None     # the output file
    out_type = None   # the dam_repository.Type of the output Component
    fake = False        # set to have just the command line printed

    def __init__(self, deferred, workspace, item_id, source_variant_name):    
        if self.get_cmdline is None:
            raise Exception('Adapter is an abstract base class: instantiate a derived class')
        self.deferred = deferred
        self.workspace = workspace
        self.item, self.source = get_source_rendition(item_id, source_variant_name, workspace)

    def handle_result(self, result):
        log.debug('handle_result %s' % str(result))
        log.debug("[save_component] component %s" % self.out_comp.pk)        
        log.debug('##############\n%s\n' % result['data'])
        
        directory, name = os.path.split(self.out_file)
        self.out_comp.uri = name
        self.out_comp.save()
        self.item.update_time = time.time()
        self.item.save()
        
        self.deferred.callback(self.out_file)
        
    def handle_error(self, result):
        self.deferred.errback(Failure(Exception(result.getErrorMessage())))

    def execute(self, output_variant_name, output_type, **params):     
        # get basic data (avoid creating stuff in DB)
        self.get_cmdline(output_variant_name, output_type, **params)
        output_variant = Variant.objects.get(name = output_variant_name)
        self.out_comp = self.item.create_variant(output_variant, self.workspace, self.out_type)
        self.out_comp.source = self.source

        args = splitstring(self.cmdline)
        if self.fake:
            log.debug('######### Command line:\n%s' % str(args))
        else:
            proxy = Proxy(self.md_server)
            d = proxy.call(self.remote_exe, args, self.env)
            d.addCallbacks(self.handle_result, self.handle_error)
        return self.deferred

