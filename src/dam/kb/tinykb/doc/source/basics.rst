Basic concepts and examples
===========================

This section explains the basic concepts needed for unsing TinyKB,
through some simple examples.


The knowledge base session
--------------------------

TinyKB is centered around the :py:class:`Session` object, which
handles the connection to the unerlying SQL DBMS, and offers some
methods for exploring and modifying the contents of the knowledge
base.

A working session can be created with::

    from tinykb.session import Session
    ses = Session('postgresql://tinykb:tinykb@localhost/tinykb')

where the argument is a DBMS connection string, as supported by
`SQLAlchemy`_.


Creating a knowledge base root class
------------------------------------

The session object contains an ``orm`` property, which is a
dynamically-generated module object, providing access the Python
classes mapped to the underlying knowledge base.  In particular,
:py:class:`orm.KBClass` and :py:class:`orm.KBRootClass` can be used to
define new KB classes bound to the session.

Let's say, for example, that we need to define a KB class for
representing buildings and their related information::

    orm = ses.orm
    attrs = ses.orm.attributes
    building = orm.KBRootClass('Building', explicit_id='building',
                               notes='Generic building',
                               attributes=[attrs.Boolean('Open to the public',
                                                         default=True,
                                                         id_='is_open'),
                                           attrs.Integer('Height', min_=0,
					                 id_='height'),
                                           attrs.String('Location',
					                id_='location'),
                                           attrs.Date('Date of completion',
                                                      id_='completion')])

Here, the ``Building`` KB class is defined as a root class
(i.e. placed at the top of the inheritance hierarchy) featuring a set
of named *attributes* with different types.  Those attributes are
themselves objects, whose classes are bound to the session throught
the ``orm.attributes`` dynamically-generated module.  The optional
``id_`` keyword argument provides an attribute identifier (if not
provided, it will be auto-generated from the descriptive name).

Once created, the new KB class can be *realized*, i.e. implemented in
the underlying SQL DBMS::

    building.realize()


Creating knowledge base objects
-------------------------------

The ``python_class`` property of a realized KB classe provides the
corresponding Python class::

    BuildingClass = building.python_class

``BuildingClass`` derives from :py:class:`orm.KBObject`, which is the base class for all dynamically-generated Python classes mapped to the KB.

It is now possible to instantiate Python objects representing
buildings::

    b = BuildingClass('Test building', explicit_id='test_building')
    b.is_open = True
    b.height = 42
    b.location = 'Sesame Street'
    b.completion = '1991-01-12'

The ``b`` attribute names reflect the ``id_`` keyword argument, as
provided when the KB class attributes were defined.


Creating a derived class on the knowledge base
----------------------------------------------

It's also possible to define derived classes::

    church = ses.orm.KBClass('Church',  explicit_id='church',
                             superclass=building, notes='A church',
                             attributes=[attrs.Choice('Number of naves',
                                                      ['One', 'Two',
                                                       'Three or more'],
                                                      default='Two'),
                                         attrs.ObjectReference(
                                             'Nearby buildings',
                                             target_class=BuildingClass,
                                             multivalued=True)])

The derived class can be realized and used just like the root class::

    church.realize()
    ChurchClass = church.python_class


Objects ID generation and multivalued attributes
------------------------------------------------

Let's create a new ``ChurchClass`` object, giving a value to its
attributes:

    c = ChurchClass('A test church')
    c.is_open = False
    c.height = 24
    c.location = 'Faraway Place'
    c.completion = '1342-01-01'
    c.number_of_naves = 'Two'
    c.nearby_buildings.append(b)

In this example, the ``number_of_naves`` and ``nearby_buildings``
attribute identifiers are autogenerated by their descreptive names
(since ``id_`` was not provided when the attributes where defined).

It is also interesting to notice the behaviour of the
``nearby_buildings`` attribute: its type describes object references
restricted to instances of ``BuildingClass``.  Furthermore, the
attribute is declared as ``multivalued``: thus, instead of being
scalar, it is a list (initially empty), whose values can be added or
removed.


Saving objects
--------------

Newly-created objects (in this example, ``b`` and ``c``) are not
automatically persisted in the underlying SQL DB: they need to be
added to the current transaction, which in turn needs to be committed.::

    ses.add_all([b, c])
    ses.commit()


Retrieving classes and objects from the KB
------------------------------------------

The knowledge base can be queried in order to retrieve the existing
classes and objects.  Let's say that we've closed the previous working
session, and that we're opening a new one::

    from tinykb.session import Session
    ses = Session('postgresql://tinykb:tinykb@localhost/tinykb')

    KBBuilding = ses.class_('building')
    ChurchClass = ses.python_class('church')

Here, we've retrieved the same KB classes of the previous examples,
using their ID: ``KBBuilding`` is a :py:class:`KBRootClass` object,
while ``ChurchClass`` is a ready-to-use Python class.

Single objects can be retrieved using their ID::

    b = ses.object('test_building')

It's also possible to retrieve all objects belonging to a given class::

    churches = ses.objects(ChurchClass)

Here, ``churches`` is an iterator yielding al the ``Church``
instances.  Since we know that there is one such instances (that we
created above), we can use::

    c = churches.next()


Deleting KB objects
-------------------

Objects can be deleted by invoking the :py:meth:`KBObject.delete`
method, and committing the current transaction::

    c.delete()
    ses.commit()


Deleting KB classes
-------------------

KB classes can be deleted if (and only if) they are not referenced by
other classes or instances.  Since we have deleted the only
``ChurchClass`` instance, we can now execute::

    KBChurch = ses.class_('church')
    KBChurch.delete()
    ses.commit()

Finally, we also need to cleanup the SQL DB tables and structures
which were created when we realized the KB class::

    KBChurch.unrealize()

.. _SQLAlchemy: http://www.sqlalchemy.org/
