Basic concepts and examples
===========================

TinyKB is centered around the Session object, which handles the
connection to the unerlying SQL DBMS, and offers some methods for
exploring and modifying the contents of the knowledge base.

A working session can be created with::

    from tinykb.session import Session
    ses = Session('postgresql://tinykb:tinykb@localhost/tinykb')

where the argument is a DBMS connection string, as supported by
`SQLAlchemy`_.

The session object contains an ``orm`` property which can be used to
access the Python classes mapped to the underlying knowledge base.  In
particular, ``KBClass`` and ``KBRootClass`` can be used to define new
KB classes bound to the session.

Let's say, for example, that we need to define a KB class for
representing buildings and their related information::

    orm = ses.orm
    attrs = ses.orm.attributes
    building = orm.KBRootClass('Building', explicit_id='building',
                               notes='Generic building',
                               attributes=[attrs.Boolean('Open to the public',
                                                         default=True,
							 explicit_id='is_open'),
                                           attrs.Integer('Height', min_=0,
					                 explicit_id='height'),
                                           attrs.String('Location',
					                explicit_id='location'),
                                           attrs.Date('Date of completion',
                                                      'explicit_id='completion')])

Here, the "Building" KB class is defined as a root class (i.e. placed
at the top of the inheritance hierarchy) featuring a set of named
attributes with different types.  Those attributes are themselves
objects, whose classes are bound to the session throught the
``orm.attributes`` properties.  The optional ``explcit_id`` keyword
argument provides an attribute identifier (if not provided, it will be
auto-generated from the descriptive name).

Once created, the new KB class can be "realized", i.e. implemented in
the underlying SQL DBMS::

    building.realize()

The ``python_class`` property of realized KB classes provides the
corresponding Python class::

    BuildingClass = building.python_class

``BuildingClass`` can now be used to instantiate Python objects
representing buildings::

    b = BuildingClass('Test building')
    b.is_open = True
    b.height = 42
    b.location = 'Sesame Street'
    b.completion = '1991-01-12'

The ``b`` attribute names are the values of the ``explicit_id``
keyword argument, used when the KB class attributes were defined.

It's also possible to define derived classes::

    church = ses.orm.KBClass('Church',  explicit_id='church',
                             superclass=building, notes='A church',
                             attributes=[attrs.Choice('Number of naves',
                                                      ['One', 'Two',
                                                       'Three or more'],
                                                      default='Two'),
                                         attrs.ObjectReference(
                                             'Nearby buildings',
                                             target_class=BuildingClass,
                                             multivalued=True)])

The derived class can be realized and used just like the root class::

    church.realize()
    Church = church.python_class

    c = ChurchClass('A test church')
    c.is_open = False
    c.height = 24
    c.location = 'Faraway Place'
    c.completion = '1342-01-01'
    c.number_of_naves = 'Two'
    c.nearby_buildings.append(b)

In this example, the ``number_of_naves`` and ``nearby_buildings``
attribute identifiers where autogenerated by their descreptive names
(since ``explicit_id`` was not used when the attributes where
defined).

It is also interesting to notice the behaviour of
``nearby_buildings``: its type describes object references restricted
to instances of ``BuildingClass``.  Furthermore, the attribute is
declared as ``multivalued``: thus, instead of being scalar, it is a
list (initially empty), whose values can be added or removed.

.. _SQLAlchemy: http://www.sqlalchemy.org/
