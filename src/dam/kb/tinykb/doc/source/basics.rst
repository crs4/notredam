Basic concepts and examples
===========================

This section explains the basic concepts of TinyKB, through some
simple examples.


The knowledge base session
--------------------------

TinyKB is centered around the :py:class:`Session <session.Session>`
object, which handles the connection to the underlying SQL DBMS,
manages transactions, and offers some methods for exploring and
modifying the contents of the knowledge base.

A working session can be created with::

    from tinykb.session import Session
    ses = Session('postgresql://tinykb:tinykb@localhost/tinykb')

where the constructor argument is a DBMS connection string, as
supported by `SQLAlchemy`_.

.. _label-kb-root-class:

Creating a knowledge base root class
------------------------------------

The session object contains an :py:mod:`orm` property, which is
a dynamically-generated module object, providing access the Python
classes mapped to the underlying knowledge base.  In particular,
:py:class:`orm.KBClass` and :py:class:`orm.KBRootClass` can be used to
define new KB classes bound to the session.

Let's say, for example, that we want to define a KB class for
representing buildings (with some related information)::

    orm = ses.orm
    attrs = ses.orm.attributes
    kb_building = orm.KBRootClass('Building', explicit_id='building',
                                  notes='Generic building',
                                  attributes=[attrs.Boolean('Open for visits',
                                                            default=True,
                                                            id_='is_open'),
                                              attrs.Integer('Height', min_=0,
                                                            id_='height'),
                                              attrs.String('Location',
                                                           id_='location'),
                                              attrs.Date('Date of completion',
                                                         id_='completion')])

Here, the ``kb_building`` KB class is defined as a root class
(i.e. placed at the top of the inheritance hierarchy) featuring a set
of named attributes with different types.  Those attributes are
themselves objects, whose classes are bound to the session throught
the :py:mod:`orm.attributes` dynamically-generated module.  The
optional ``id_`` keyword argument provides an attribute identifier (if
not provided, it will be auto-generated from the descriptive name).

Once created, the new KB class can be *realized*, i.e. implemented in
the underlying SQL DBMS::

    ses.realize(kb_building)


Creating knowledge base objects
-------------------------------

The ``python_class`` property of a realized KB class provides the
corresponding Python class::

    BuildingClass = kb_building.python_class

``BuildingClass`` derives from :py:class:`orm.KBObject`, which is the base class for all dynamically-generated Python classes mapped to the KB.

It is now possible to instantiate Python objects representing
buildings::

    b = BuildingClass('Test building', explicit_id='test_building')
    b.is_open = True
    b.height = 42
    b.location = 'Sesame Street'
    b.completion = '1991-01-12'

The ``b`` attribute names reflect the ``id_`` keyword argument, as
provided when the KB class attributes were defined.


Creating a derived class on the knowledge base
----------------------------------------------

It's also possible to define derived classes::

    kb_church = ses.orm.KBClass('Church',  explicit_id='church',
                             superclass=kb_building, notes='A church',
                             attributes=[attrs.Choice('Number of naves',
                                                      ['One', 'Two',
                                                       'Three or more'],
                                                      default='Two'),
                                         attrs.ObjectReference(
                                             'Nearby buildings',
                                             target_class=BuildingClass,
                                             multivalued=True)])

The derived class can be realized and used just like the root class::

    ses.realize(kb_church)
    ChurchClass = church.python_class


Object/attribute ID generation and multivalued attributes
---------------------------------------------------------

Let's now create a new ``ChurchClass`` object, giving a value to its
attributes::

    c = ChurchClass('A test church')
    c.is_open = False
    c.height = 24
    c.location = 'Faraway Place'
    c.completion = '1342-01-01'
    c.number_of_naves = 'Two'
    c.nearby_buildings.append(b)

In this example the ``c`` unique object identifier will be
autogenerated, since the ``explicit_id`` constructor argument was not
provided.

Furthermore, the ``number_of_naves`` and ``nearby_buildings``
attribute identifiers are autogenerated by their descreptive names
(since ``id_`` was not provided when the attributes where defined).
They resemble the respective attribute names, with some obvious
normalization.

It is also interesting to notice the behaviour of the
``nearby_buildings`` attribute: its type describes object references
restricted to instances of ``BuildingClass``.  Furthermore, the
attribute is declared as ``multivalued``: thus, instead of being
scalar, it is a list (initially empty), whose values can be added or
removed.


Saving objects
--------------

Newly-created objects (in this example, ``b`` and ``c``) are not
automatically persisted in the underlying SQL DB: they need to be
added to the current transaction, which in turn needs to be committed.::

    ses.add_all([b, c])
    ses.commit()


Retrieving classes and objects from the KB
------------------------------------------

The knowledge base can be queried in order to retrieve the existing
classes and objects.  Let's say that we've closed the previous working
session, and that we're opening a new one::

    from tinykb.session import Session
    ses = Session('postgresql://tinykb:tinykb@localhost/tinykb')

    kb_building = ses.class_('building')
    ChurchClass = ses.python_class('church')

Here, we've retrieved the same KB classes of the previous examples,
using their ID: thus, ``KBBuilding`` is a
:py:class:`ses.orm.KBRootClass <orm.KBRootClass>` object, while
``ChurchClass`` is a ready-to-use Python class mapped to the KB.

Single objects can be retrieved using their ID as well::

    b = ses.object('test_building')

It's also possible to collect all objects belonging to a given KB
class::

    churches = ses.objects(ChurchClass)

Here, ``churches`` is an iterator yielding all the ``Church``
instances.  Since we know that there is one such instances (that we
created above), we can use::

    c = churches.next()

in order to retrieve it.

Deleting KB objects
-------------------

Objects can be deleted by invoking the :py:meth:`KBObject.delete`
method, and committing the current transaction::

    ses.delete(c)
    ses.commit()


Deleting KB classes
-------------------

KB classes can be deleted if (and only if) they are not referenced by
other classes or instances.  Since we have deleted the only
``ChurchClass`` instance, we can now execute::

    kb_church = ses.class_('church')
    ses.delete(kb_church)
    ses.commit()

After the commit, the class-related SQL DB tables and structures (the
ones created with ``realize()``) will be cleaned up as well.


.. _SQLAlchemy: http://www.sqlalchemy.org/
